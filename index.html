<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dr. Coochie's Mario Super Sluggers League</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
  body {
    font-family: 'Press Start 2P', cursive, Arial, sans-serif; /* Added a retro font */
    background: linear-gradient(to bottom, #1a1a1a, #000000); /* Darker, gradient background */
    color: #e0e0e0; /* Lighter text for contrast */
    text-align: center;
    margin: 0;
    padding: 0 10px 50px;
    overflow-x: hidden; /* Prevent horizontal scroll */
  }

  h1 {
    font-size: 2.5rem;
    color: #ffeb3b; /* Mario coin yellow */
    text-shadow: 3px 3px 0px #c62828; /* Red shadow for pop */
    margin-bottom: 2rem;
    padding-top: 20px;
  }
  h2 {
    color: #8bc34a; /* Green pipe color */
    margin-top: 3rem;
    margin-bottom: 1rem;
    border-bottom: 2px solid #8bc34a;
    display: inline-block;
    padding-bottom: 5px;
  }
  .section-container {
    background: rgba(17, 17, 17, 0.8); /* Slightly transparent dark background */
    border: 2px solid #440000;
    border-radius: 10px;
    padding: 20px;
    margin: 30px auto;
    max-width: 700px;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); /* More vibrant shadow */
  }
  #wheelCanvas, #stageWheelCanvas {
    margin: 20px auto;
    display: block;
    background: #333;
    border-radius: 50%;
    box-shadow: 0 0 20px #ff0000, 0 0 40px #ff6666; /* Enhanced wheel glow */
  }
  #coin {
    margin: 20px auto;
    cursor: pointer;
    width: 100px;
    height: 100px;
    perspective: 600px;
    position: relative; /* For the glow */
  }
  #coinInner {
    width: 100px;
    height: 100px;
    background: gold;
    border-radius: 50%;
    line-height: 100px;
    font-weight: bold;
    font-size: 1.4rem;
    color: #444;
    user-select: none;
    transform-style: preserve-3d;
    box-shadow: 0 0 15px gold, 0 0 30px #ffdf00; /* Enhanced coin glow */
    transition: background 0.3s ease, color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition */
  }
  #coinInner.day {
    background: #fce570;
    color: #444;
    box-shadow: 0 0 15px #ffea70, 0 0 30px #ffe100;
  }
  #coinInner.night {
    background: #334466;
    color: #ddd;
    box-shadow: 0 0 15px #5577aa, 0 0 30px #77aadd;
  }
  table {
    margin: 20px auto;
    width: 90%; /* Slightly wider tables */
    border-collapse: collapse;
    background: #0a0a0a; /* Darker table background */
    border-radius: 8px; /* Slightly more rounded corners */
    overflow: hidden;
    box-shadow: 0 0 15px #880000; /* Enhanced table shadow */
    color: #e0e0e0;
  }
  th, td {
    padding: 12px; /* More padding */
    border-bottom: 1px solid #666; /* Lighter border */
    text-align: center; /* Center table text */
  }
  th {
    background: #660000; /* Darker red for headers */
    color: white;
    text-transform: uppercase;
    font-size: 0.9rem;
  }
  input[type="number"], input[type="text"], select { /* Added select for dropdown */
    width: calc(100% - 20px); /* Adjust for padding */
    padding: 10px; /* More padding */
    margin-bottom: 10px; /* Space between inputs */
    border-radius: 5px;
    border: 1px solid #555;
    background: #222;
    color: #eee;
    box-sizing: border-box; /* Include padding in width */
  }
  button {
    margin-top: 15px;
    padding: 12px 20px; /* Larger buttons */
    font-size: 1.1rem;
    cursor: pointer;
    border-radius: 6px;
    border: none;
    background: #d32f2f; /* Brighter red button */
    color: white;
    box-shadow: 0 5px 8px #9a0000;
    transition: background 0.2s ease, box-shadow 0.2s ease;
  }
  button:hover {
    background: #ff5252; /* Even brighter on hover */
    box-shadow: 0 6px 10px #bb0000;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
    box-shadow: none;
  }
  .admin-section {
    background: #1a1a1a;
    padding: 25px;
    margin: 20px auto;
    max-width: 650px;
    border-radius: 12px;
    box-shadow: 0 0 15px #660000;
    border: 1px solid #330000;
  }
  /* No pointer style needed as it's removed */

  /* Specific styles for Draft Board */
  #draftBoardTable {
    width: 95%; /* Make draft board wider */
    max-width: 900px; /* Set a max-width for very large screens */
    overflow-x: auto; /* Allow horizontal scrolling if content overflows */
    display: block; /* Ensures overflow-x works */
  }
  #draftBoardTable th,
  #draftBoardTable td {
    font-size: 0.7rem; /* Smaller font for draft board cells */
    white-space: nowrap; /* Prevent text wrapping */
    padding: 8px 5px; /* Adjust padding to give more room */
    min-width: 80px; /* Minimum width for each pick column to accommodate 20 chars */
  }
  #draftBoardTable th:first-child,
  #draftBoardTable td:first-child,
  #draftBoardTable th:nth-child(2),
  #draftBoardTable td:nth-child(2) {
    min-width: 100px; /* Slightly wider for Names and Captains */
  }
  .info-section {
    background: #1a1a1a;
    padding: 25px;
    margin: 20px auto;
    max-width: 650px;
    border-radius: 12px;
    box-shadow: 0 0 15px #0056b3; /* Blue shadow for info */
    border: 1px solid #003366;
  }
  .info-section a {
    color: #87ceeb; /* Light blue link */
    text-decoration: none;
    font-weight: bold;
  }
  .info-section a:hover {
    text-decoration: underline;
  }
  .delete-btn {
    background-color: #dc3545; /* Red delete button */
    color: white;
    border: none;
    padding: 5px 10px;
    font-size: 0.8rem;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    margin-left: 10px; /* Space from record */
  }
  .delete-btn:hover {
    background-color: #c82333;
  }
  .delete-pick-btn { /* Style for draft pick delete button */
    background-color: #ffc107; /* Yellowish color for delete pick */
    color: #333;
    border: none;
    padding: 3px 6px;
    font-size: 0.65rem;
    border-radius: 3px;
    cursor: pointer;
    transition: opacity 0.2s ease-in-out; /* Smooth transition for opacity */
    margin-left: 5px;
    vertical-align: middle; /* Align with text */
    opacity: 0; /* Hidden by default */
    pointer-events: none; /* Make it unclickable when invisible */
  }
  .delete-pick-btn:hover {
    background-color: #e0a800;
  }
  /* Show delete button on hover over the table cell */
  #draftBoardTable td:hover .delete-pick-btn {
    opacity: 1; /* Visible on hover */
    pointer-events: auto; /* Make it clickable when visible */
  }
</style>
</head>
<body>

<h1>Dr. Coochie's Mario Super Sluggers League</h1>

<div class="section-container">
  <h2>Name Wheel</h2>
  <canvas id="wheelCanvas" width="300" height="300"></canvas><br />
  <button onclick="spinNameWheel()" id="nameSpinBtn">Spin Name Wheel</button>
  <p id="nameResult"></p>
  <button onclick="removeSelectedName()" id="removeNameBtn" style="display: none;">Remove Selected Name</button>
</div>

<div class="section-container">
  <h2>Day/Night Coin Flip</h2>
  <div id="coin" onclick="flipCoin()">
    <div id="coinInner" class="day">DAY</div>
  </div>
</div>

<div class="section-container">
  <h2>Stage Wheel</h2>
  <canvas id="stageWheelCanvas" width="300" height="300"></canvas><br />
  <button onclick="spinStageWheel()" id="stageSpinBtn">Spin Stage Wheel</button>
  <p id="stageResult"></p>
</div>

<div class="admin-section">
  <h2>Draft Board (Admin Only)</h2>
  <table id="draftBoardTable">
    <thead>
      <tr>
        <th>Names</th> <th>Captains</th> <th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <select id="draftCaptainSelect">
    <option value="">Select Player Name</option> </select>
  <input type="number" id="draftPickNumber" placeholder="Pick Number (1-8)" min="1" max="8" />
  <input type="text" id="draftedPlayerName" placeholder="Player drafted" />
  <button onclick="addDraftPick()">Add Draft Pick</button>
</div>

<div class="admin-section">
  <h2>Standings Board (Admin Only)</h2>
  <table id="standingsTable">
    <thead>
      <tr><th>Team Name</th><th>Record</th><th>Actions</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <input type="text" id="standingTeamName" placeholder="Team Name" />
  <input type="text" id="standingRecord" placeholder="Record (e.g., 5-2)" />
  <button onclick="updateStandings()">Update Standing</button>
</div>

<div class="info-section">
  <h2>Info</h2>
  <p>For more information, please refer to: <a href="https://docs.google.com/document/d/1O4Olvgzd2_bEYItGlNP0GiZdndDOCediM0kJEvJ0U_M/edit?usp=sharing" target="_blank">Mario Super Sluggers League Rules</a></p>
</div>

<script>
  // Initialize Tone.js for sound effects
  // A simple synth for clicking sound
  const clickSynth = new Tone.Synth({
    oscillator: { type: "square" },
    envelope: { attack: 0.001, decay: 0.05, sustain: 0.0, release: 0.05 }
  }).toDestination();

  // Use PolySynth for playing chords
  const congratsSynth = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "triangle" },
    envelope: { attack: 0.05, decay: 0.2, sustain: 0.1, release: 0.5 }
  }).toDestination();

  // --- Wheel drawing common function ---
  // Now accepts a fontSize parameter
  function drawWheel(items, ctx, colors, fontSize) {
    const num = items.length;
    const arcSize = (2 * Math.PI) / num;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear only once per frame

    const centerX = ctx.canvas.width / 2;
    const centerY = ctx.canvas.height / 2;
    const radius = centerX - 10;

    for (let i = 0; i < num; i++) {
      const startAngle = i * arcSize;
      const endAngle = startAngle + arcSize;

      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.fillStyle = colors[i % colors.length];
      ctx.arc(centerX, centerY, radius, startAngle, endAngle);
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.save(); // Save context before rotating for text
      ctx.translate(centerX, centerY); // Move to center for rotation
      // Rotate to the middle of the segment, then add 90 degrees (PI/2) to make text upright
      ctx.rotate(startAngle + arcSize / 2 + Math.PI / 2);

      ctx.textAlign = "center";       // Center the text horizontally
      ctx.textBaseline = "middle";    // Center the text vertically
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${fontSize}px 'Press Start 2P'`; // Use the passed fontSize
      // Position text at the top of the segment (outwards from center)
      // X=0 is center of segment, Y is distance from center (upwards due to rotation)
      ctx.fillText(items[i], 0, -radius + 20);
      ctx.restore(); // Restore context after text rotation
    }
  }

  // --- Name Wheel ---
  // Default names if localStorage is empty
  const defaultNames = ["Brian", "Dylan", "Jacob", "Grant", "Phil", "Cole", "Murph"];
  // Load names from localStorage, or use default if not found
  let names = JSON.parse(localStorage.getItem('marioSluggersNames')) || defaultNames;

  const nameCanvas = document.getElementById('wheelCanvas');
  const nameCtx = nameCanvas.getContext('2d');
  const nameColors = ['#ff6666', '#cc4444', '#ff8888', '#ee5555']; // More color variety
  // Initial draw of the name wheel
  drawWheel(names, nameCtx, nameColors, 14);

  let nameRotation = 0;
  let nameSpinning = false;
  let lastClickTime = 0;
  const clickInterval = 100; // milliseconds between clicks
  let lastSelectedIndex = -1; // To store the index of the last selected name

  const removeNameBtn = document.getElementById('removeNameBtn');

  function spinNameWheel() {
    if(nameSpinning || names.length === 0) return; // Prevent spin if already spinning or no names
    nameSpinning = true;
    document.getElementById('nameSpinBtn').disabled = true; // Disable button during spin
    removeNameBtn.style.display = 'none'; // Hide remove button
    document.getElementById('nameResult').textContent = "Spinning...";

    const spins = Math.floor(Math.random() * 10) + 15; // 15-25 spins for visual effect
    const totalRotation = spins * 2 * Math.PI + (Math.random() * 2 * Math.PI); // Random final position
    const duration = 4000; // 4 seconds animation
    const start = performance.now();

    function animate(time) {
      let elapsed = time - start;
      let progress = Math.min(elapsed / duration, 1);
      // Ease out cubic function for smooth deceleration
      progress = 1 - Math.pow(1 - progress, 3);
      nameRotation = totalRotation * progress;
      nameRotation %= 2 * Math.PI; // Keep rotation within 0 to 2*PI

      nameCtx.clearRect(0, 0, nameCanvas.width, nameCanvas.height); // Clear canvas for redraw
      nameCtx.save(); // Save context before applying overall wheel transformation
      nameCtx.translate(nameCanvas.width / 2, nameCanvas.height / 2); // Move origin to center
      nameCtx.rotate(nameRotation); // Apply overall wheel rotation
      nameCtx.translate(-nameCanvas.width / 2, -nameCanvas.height / 2); // Move origin back (relative to canvas top-left)

      drawWheel(names, nameCtx, nameColors, 14); // drawWheel now draws the wheel as if unrotated

      nameCtx.restore(); // Restore context after overall wheel transformation

      // Play click sound at intervals
      if (time - lastClickTime > clickInterval && progress < 0.95) { // Stop clicks near the end
        clickSynth.triggerAttackRelease("C4", "8n");
        lastClickTime = time;
      }

      if (progress < 1) {
        requestAnimationFrame(animate); // Continue animation
      } else {
        nameSpinning = false;
        document.getElementById('nameSpinBtn').disabled = false; // Re-enable button

        // Calculate the selected item based on the final rotation
        // The winner is the segment at the 12 o'clock (top) position.
        // The angle for the 12 o'clock position in canvas coordinates is PI/2 (90 degrees).
        // If the wheel has rotated 'nameRotation' clockwise, we need to find which segment
        // was originally at (PI/2 - nameRotation).
        let selectedAngle = (Math.PI / 2 - nameRotation);
        // Normalize angle to be between 0 and 2*PI
        selectedAngle = (selectedAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);

        const numNames = names.length;
        const arcSize = (2 * Math.PI) / numNames;

        // Determine the index of the segment whose *center* is at this `selectedAngle`.
        lastSelectedIndex = Math.floor(((selectedAngle - arcSize / 2 + 2 * Math.PI) % (2 * Math.PI)) / arcSize);

        // Ensure index wraps around correctly for the last segment
        if (lastSelectedIndex >= numNames) lastSelectedIndex = numNames - 1;
        if (lastSelectedIndex < 0) lastSelectedIndex = 0;


        document.getElementById('nameResult').textContent = "Selected: " + names[lastSelectedIndex] + "!";
        congratsSynth.triggerAttackRelease(["C5", "E5", "G5"], "2n"); // Play congratulatory chord

        // Show remove button after a name is selected
        if (names.length > 0) {
          removeNameBtn.style.display = 'inline-block';
        }
      }
    }
    requestAnimationFrame(animate); // Start animation
  }

  function removeSelectedName() {
    if (lastSelectedIndex !== -1 && names.length > 0) {
      const removedName = names.splice(lastSelectedIndex, 1); // Remove the name
      localStorage.setItem('marioSluggersNames', JSON.stringify(names)); // Save updated names

      // Correctly redraw the wheel with the new names and reset rotation
      nameRotation = 0; // Reset visual rotation
      nameCtx.clearRect(0, 0, nameCanvas.width, nameCanvas.height);
      nameCtx.save();
      nameCtx.translate(nameCanvas.width / 2, nameCanvas.height / 2);
      nameCtx.rotate(nameRotation);
      nameCtx.translate(-nameCanvas.width / 2, -nameCanvas.height / 2);
      drawWheel(names, nameCtx, nameColors, 14);
      nameCtx.restore();

      document.getElementById('nameResult').textContent = removedName[0] + " has been removed!";
      removeNameBtn.style.display = 'none'; // Hide button after removal
      lastSelectedIndex = -1; // Reset selected index

      if (names.length === 0) {
        document.getElementById('nameResult').textContent = "All names have been removed!";
        document.getElementById('nameSpinBtn').disabled = true; // Disable spin if no names left
      }
    }
  }

  // --- Coin flip ---
  const coinInner = document.getElementById('coinInner');
  let flipping = false;

  function flipCoin() {
    if(flipping) return; // Prevent multiple flips while animating
    flipping = true;

    let rotation = 0;
    const spins = 3; // Number of full 360-degree spins
    const duration = 1200; // Animation duration in milliseconds
    const start = performance.now();

    function animate(time) {
      let elapsed = time - start;
      let progress = Math.min(elapsed / duration, 1);
      // Rotate from 0 to spins * 360deg
      rotation = spins * 360 * progress;
      coinInner.style.transform = `rotateY(${rotation}deg)`;

      if (progress < 1) {
        requestAnimationFrame(animate); // Continue animation
      } else {
        // Determine result randomly (50/50 chance)
        const resultIsDay = Math.random() < 0.5; // True for Day, False for Night
        if (resultIsDay) {
          coinInner.className = 'day';
          coinInner.textContent = 'DAY';
        } else {
          coinInner.className = 'night';
          coinInner.textContent = 'NIGHT';
        }
        flipping = false;
        coinInner.style.transform = ''; // Reset transform for next flip to start from 0deg
      }
    }
    requestAnimationFrame(animate); // Start animation
  }

  // --- Stage Wheel ---
  const stages = [
    "Bowser/Bowser Jr. Castle", "Mario Stadium", "Yoshi Park",
    "Donkey Kong Jungle", "Wario City", "Daisy Cruiser"
  ];
  const stageCanvas = document.getElementById('stageWheelCanvas');
  const stageCtx = stageCanvas.getContext('2d');
  const stageColors = ['#4caf50', '#8bc34a', '#689f38', '#388e3c']; // Greenish palette for stages
  drawWheel(stages, stageCtx, stageColors, 11); // Pass 11px for Stage Wheel

  let stageRotation = 0;
  let stageSpinning = false;
  let lastStageClickTime = 0;

  function spinStageWheel() {
    if(stageSpinning) return;
    stageSpinning = true;
    document.getElementById('stageSpinBtn').disabled = true;
    document.getElementById('stageResult').textContent = "Spinning...";

    const spins = Math.floor(Math.random() * 10) + 15;
    const totalRotation = spins * 2 * Math.PI + (Math.random() * 2 * Math.PI);
    const duration = 4000;
    const start = performance.now();

    function animate(time) {
      let elapsed = time - start;
      let progress = Math.min(elapsed / duration, 1);
      progress = 1 - Math.pow(1 - progress, 3);
      stageRotation = totalRotation * progress;
      stageRotation %= 2 * Math.PI;

      stageCtx.clearRect(0, 0, stageCanvas.width, stageCanvas.height); // Clear canvas for redraw
      stageCtx.save(); // Save context before applying overall wheel transformation
      stageCtx.translate(stageCanvas.width / 2, stageCanvas.height / 2); // Move origin to center
      stageCtx.rotate(stageRotation); // Apply overall wheel rotation
      stageCtx.translate(-stageCanvas.width / 2, -stageCanvas.height / 2); // Move origin back (relative to canvas top-left)

      drawWheel(stages, stageCtx, stageColors, 11); // Redraw with 11px font size

      stageCtx.restore(); // Restore context after overall wheel transformation

      // Play click sound at intervals
      if (time - lastStageClickTime > clickInterval && progress < 0.95) { // Stop clicks near the end
        clickSynth.triggerAttackRelease("C4", "8n");
        lastStageClickTime = time;
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        stageSpinning = false;
        document.getElementById('stageSpinBtn').disabled = false;

        // Calculate the selected item based on the final rotation
        // The winner is the segment at the 12 o'clock (top) position.
        // The angle for the 12 o'clock position in canvas coordinates is PI/2 (90 degrees).
        // If the wheel has rotated 'stageRotation' clockwise, we need to find which segment
        // was originally at (PI/2 - stageRotation).
        let selectedAngle = (Math.PI / 2 - stageRotation);
        // Normalize angle to be between 0 and 2*PI
        selectedAngle = (selectedAngle % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI);

        const numStages = stages.length;
        const arcSize = (2 * Math.PI) / numStages;

        // Determine the index of the segment whose *center* is at this `selectedAngle`.
        let index = Math.floor(((selectedAngle - arcSize / 2 + 2 * Math.PI) % (2 * Math.PI)) / arcSize);
        // Ensure index wraps around correctly for the last segment
        if (index >= numStages) index = numStages - 1;
        if (index < 0) index = 0;


        document.getElementById('stageResult').textContent = "Selected Stage: " + stages[index] + "!";
        congratsSynth.triggerAttackRelease(["C5", "E5", "G5"], "2n"); // Play congratulatory chord
      }
    }
    requestAnimationFrame(animate);
  }

  // --- Draft Board ---
  const draftBoardTableBody = document.getElementById('draftBoardTable').querySelector('tbody');
  const draftPlayerNames = ["Brian", "Dylan", "Jacob", "Grant", "Phil", "Cole", "Murph"]; // Player names
  const captainCharacters = { // Mapping player names to their character captains
    "Brian": "Bowser Jr.",
    "Dylan": "Diddy Kong",
    "Jacob": "Donkey Kong",
    "Cole": "Waluigi",
    "Murph": "Mario",
    "Phil": "Yoshi",
    "Grant": "Daisy"
  };
  const numDraftPicks = 8; // Number of draft pick columns

  // Initialize draft board data from localStorage or with default structure
  let draftBoardData = JSON.parse(localStorage.getItem('marioSluggersDraftBoard')) || [];

  // If no data in localStorage, or if structure needs re-initialization (e.g., new players/columns)
  if (draftBoardData.length === 0 || draftBoardData.length !== draftPlayerNames.length || !draftBoardData[0].captainCharacter) {
    draftBoardData = draftPlayerNames.map(playerName => {
      return {
        name: playerName,
        captainCharacter: captainCharacters[playerName] || 'N/A', // Assign character, default to N/A
        picks: Array(numDraftPicks).fill('') // Initialize 8 empty pick slots
      };
    });
    localStorage.setItem('marioSluggersDraftBoard', JSON.stringify(draftBoardData)); // Save initial structure
  } else {
    // If data exists, ensure it has the correct captain characters and pick array length
    draftBoardData = draftPlayerNames.map(playerName => {
      const existingRow = draftBoardData.find(row => row.name === playerName);
      if (existingRow) {
        // Update character captain in case it changed, and ensure pick array is correct length
        return {
          name: playerName,
          captainCharacter: captainCharacters[playerName] || 'N/A',
          picks: existingRow.picks.length === numDraftPicks ? existingRow.picks : Array(numDraftPicks).fill('')
        };
      } else {
        // Add new player if they weren't in previous data
        return {
          name: playerName,
          captainCharacter: captainCharacters[playerName] || 'N/A',
          picks: Array(numDraftPicks).fill('')
        };
      }
    });
    localStorage.setItem('marioSluggersDraftBoard', JSON.stringify(draftBoardData)); // Save updated structure
  }


  // Populate the captain select dropdown with player names
  const draftCaptainSelect = document.getElementById('draftCaptainSelect');
  draftPlayerNames.forEach(playerName => {
    const option = document.createElement('option');
    option.value = playerName;
    option.textContent = playerName;
    draftCaptainSelect.appendChild(option);
  });

  function renderDraftBoard() {
    draftBoardTableBody.innerHTML = ''; // Clear existing rows
    draftBoardData.forEach(rowData => {
      const row = draftBoardTableBody.insertRow();
      row.insertCell().textContent = rowData.name; // Player Name (e.g., Brian)
      row.insertCell().textContent = rowData.captainCharacter; // Character Captain (e.g., Bowser Jr.)
      // Add cells for each draft pick
      for (let i = 0; i < numDraftPicks; i++) {
        const cell = row.insertCell();
        const pickText = rowData.picks[i];
        if (pickText) {
          // Create a span for the text and a button for deletion
          const pickSpan = document.createElement('span');
          pickSpan.textContent = pickText;
          cell.appendChild(pickSpan);

          const deleteButton = document.createElement('button');
          deleteButton.textContent = 'X'; // Or 'Delete'
          deleteButton.classList.add('delete-pick-btn');
          // Attach click listener to delete the specific pick
          deleteButton.onclick = (function(player, pickIndex) {
            return function() {
              deleteDraftPick(player, pickIndex);
            };
          })(rowData.name, i); // Pass player name and 0-indexed pick number
          cell.appendChild(deleteButton);
        } else {
          cell.textContent = ''; // Keep empty if no pick
        }
      }
    });
  }

  function addDraftPick() {
    const selectedPlayerName = draftCaptainSelect.value; // This is the player name (e.g., Brian)
    const pickNumber = parseInt(document.getElementById('draftPickNumber').value, 10);
    const draftedPlayer = document.getElementById('draftedPlayerName').value.trim();

    if (!selectedPlayerName) {
      console.error('Please select a player name.');
      return;
    }
    if (isNaN(pickNumber) || pickNumber < 1 || pickNumber > numDraftPicks) {
      console.error('Please enter a valid pick number between 1 and 8.');
      return;
    }
    if (!draftedPlayer) {
      console.error('Please enter the drafted player\'s name.');
      return;
    }

    // Find the correct row in draftBoardData based on the selectedPlayerName
    const playerRow = draftBoardData.find(row => row.name === selectedPlayerName);

    if (playerRow) {
      playerRow.picks[pickNumber - 1] = draftedPlayer; // Update the specific pick (0-indexed array)
      localStorage.setItem('marioSluggersDraftBoard', JSON.stringify(draftBoardData)); // Save updated data
      renderDraftBoard(); // Re-render table
      // Clear inputs for next entry
      document.getElementById('draftPickNumber').value = '';
      document.getElementById('draftedPlayerName').value = '';
      draftCaptainSelect.value = ''; // Reset dropdown
    } else {
      console.error('Selected player not found in draft board data. This should not happen.');
    }
  }

  function deleteDraftPick(playerName, pickIndex) {
    const playerRow = draftBoardData.find(row => row.name === playerName);
    if (playerRow && playerRow.picks[pickIndex] !== undefined) {
      playerRow.picks[pickIndex] = ''; // Clear the specific pick
      localStorage.setItem('marioSluggersDraftBoard', JSON.stringify(draftBoardData)); // Save updated data
      renderDraftBoard(); // Re-render table
      console.log(`Deleted pick ${pickIndex + 1} for ${playerName}`);
    } else {
      console.error(`Could not delete pick ${pickIndex + 1} for ${playerName}.`);
    }
  }

  renderDraftBoard(); // Initial render when page loads

  // --- Standings Board ---
  const standingsTableBody = document.getElementById('standingsTable').querySelector('tbody');
  // Load standings from localStorage or initialize empty object
  const standings = JSON.parse(localStorage.getItem('marioSluggersStandings')) || {};

  function renderStandings() {
    standingsTableBody.innerHTML = ''; // Clear existing rows
    
    // Sort standings by record (wins descending, then losses ascending)
    const sortedStandings = Object.entries(standings).sort(([teamA, recordA], [teamB, recordB]) => {
      // Parse records into wins and losses
      const [winsA, lossesA] = recordA.split('-').map(Number);
      const [winsB, lossesB] = recordB.split('-').map(Number);

      // Primary sort: by wins (descending)
      if (winsA !== winsB) {
        return winsB - winsA; // Higher wins first
      }

      // Secondary sort: if wins are equal, sort by losses (ascending)
      return lossesA - lossesB; // Lower losses first
    });

    sortedStandings.forEach(([teamName, record]) => {
      const row = standingsTableBody.insertRow();
      row.insertCell().textContent = teamName;
      row.insertCell().textContent = record;
      const actionsCell = row.insertCell();
      const deleteButton = document.createElement('button');
      deleteButton.textContent = 'Delete';
      deleteButton.classList.add('delete-btn');
      deleteButton.onclick = () => deleteTeam(teamName);
      actionsCell.appendChild(deleteButton);
    });
  }

  function updateStandings() {
    const teamNameInput = document.getElementById('standingTeamName');
    const recordInput = document.getElementById('standingRecord');
    const teamName = teamNameInput.value.trim();
    const record = recordInput.value.trim();

    if (teamName && record) {
      // Basic validation for W-L format (e.g., 5-2)
      if (!/^\d+-\d+$/.test(record)) {
        console.error('Record format must be like "Wins-Losses" (e.g., 5-2).');
        // Clear the invalid record input to prompt user for correct format
        recordInput.value = ''; 
        return;
      }
      standings[teamName] = record; // Update or add team standing
      localStorage.setItem('marioSluggersStandings', JSON.stringify(standings)); // Save to localStorage
      renderStandings(); // Re-render table
      teamNameInput.value = ''; // Clear inputs on successful update
      recordInput.value = ''; // Clear inputs on successful update
    } else {
      console.error('Please enter both team name and record.');
      // Clear inputs if either is empty to ensure user re-enters
      teamNameInput.value = ''; 
      recordInput.value = '';
    }
  }

  function deleteTeam(teamName) {
    if (standings.hasOwnProperty(teamName)) {
      delete standings[teamName];
      localStorage.setItem('marioSluggersStandings', JSON.stringify(standings));
      renderStandings(); // Re-render the table
      console.log(`Team "${teamName}" deleted successfully.`);
    } else {
      console.error(`Team "${teamName}" not found.`);
    }
  }

  renderStandings(); // Initial render
</script>
</body>
</html>

